


val vals_list = bir_symbexec_treeLib.symb_execs_vals_term systs [];

val refine_preds = bir_symbexec_treeLib.get_refine_preds_list systs;

val c = ((snd o hd) vals_list);
val deps_of_symbval_def =  Define`		       
 deps_of_symbval (SymbValBE (“BExp_BinExp BIExp_Plus
          (BExp_Den (BVar "sy_SP_EL0" (BType_Imm Bit64)))
          (BExp_Const (Imm64 136w))”,_)) = ^t
`; 
val symbval_thm_def = Define`
symbval_thm  = [(^((fst o hd) vals_list),^(“BExp_BinExp BIExp_Plus
          (BExp_Den (BVar "sy_SP_EL0" (BType_Imm Bit64)))
          (BExp_Const (Imm64 136w))”))]
			     `;   
val symbval_to_thm_def = Define`
symbval_to_thm (trm1, SymbValBE (trm2,_)) = (trm1,trm2)
						`;

val tst_thm_def = Define`
tst_thm ((BVar x BType_Bool),y) = (x,y)
				  `;
				  EVAL ``MAP tst_thm symbval_thm``

 fun collect_pred_expsdeps vals (bv, (exps, deps)) =
      let
	  (*  val _ = print (term_to_string bv); *)
      (* val _ = print "\n"; *)
      val symbv = find_bv_val "collect_pred_expsdeps" vals bv;
      val _ = if true then () else
              print ("pred: " ^ (symbv_to_string symbv) ^ "\n");

      val deps_delta = deps_of_symbval "collect_pred_expsdeps" symbv;
      val _ = if true then () else
              print ("pred_deps: " ^ (List.foldr (fn (x,s) => s ^ "; " ^ (term_to_string x)) "" (Redblackset.listItems deps_delta)) ^ "\n \n");

      val exp =
       case symbv of
          SymbValBE (x, _) => x
        | _ => raise ERR "collect_pred_expsdeps" "cannot handle symbolic value type";
      (*
      val _ = print (term_to_string exp);
      val _ = print "\n";*)
      
    in
      (exp::exps, Redblackset.union(deps_delta, deps))
      end;

     open bslSyntax;

fun symbval_eq_to_touple (bv, symbv) =
    let

      val bexp =
       case symbv of
          SymbValBE (exp,_) =>
            (bv, exp)
        | _ => raise ERR "symbval_eq_to_bexp" "cannot handle symbolic value type";
      
      (* val _ = print (term_to_string bv); *)
      (* val _ = print "\n"; *)
      (* val _ = print (term_to_string bexp); *)
      (* val _ = print "\n"; *)
    in
	bexp
    end;		  
val vals  = SYST_get_vals (List.nth (systs, 20));
      val pred_bvl = SYST_get_pred (List.nth (systs, 20));

      val pred_bvl_ref = remove_crypto_preds pred_bvl [];	  

      val (pred_conjs, pred_deps) =
        List.foldr (collect_pred_expsdeps vals) ([], symbvalbe_dep_empty) pred_bvl_ref;

      val pred_depsl_ = Redblackset.listItems pred_deps;
      val pred_depsl  = List.filter (is_bvar_bound vals) pred_depsl_;

      val valsl = List.map (fn bv => (bv, find_bv_val "check_feasible_eq" vals bv))
                           pred_depsl;
	  
      val sort_vals = bir_symbexec_sortLib.refine_symb_val_list vals_list;
	  
      val vals_eql =
        List.map symbval_eq_to_touple sort_vals;


      (* val pr = add_pred (hd pred_conjs);  *)

      val exp = conj_preds_exps (tl pred_conjs) (hd pred_conjs);

      val ref_exps = subset_mem_exp (rev vals_eql) exp;



val symbval_to_thm_def = Define`
symbval_to_thm =  (^((fst o hd) vals_eql),^((snd o hd) vals_eql))
		      `;

(*Remove repeated symb vals *)

fun Remove_Repeated_symbvals ((x,y)::[]) No_Repeat =
        (No_Repeat)
  | Remove_Repeated_symbvals ((x,y)::vals) (No_Repeat: (term * term) list) =
    let
	val (x',y') = hd(vals); 
	val No_Repeat = if (identical x x')
			then No_Repeat
			else (x',y')::No_Repeat;
    in	
	Remove_Repeated_symbvals (vals) No_Repeat
    end;
		      
(* what's the next steps after symbolic execution *)
    1--> val vals_list = bir_symbexec_treeLib.symb_execs_vals_term systs [];
	     2--> val sort_vals = bir_symbexec_sortLib.refine_symb_val_list vals_list;
		      3 --> val refine_symbvals = Remove_Repeated_symbvals vals_eql [];
				4--> (rev refine_symbvals)
				(* then start translation into sapic *)
