(*

              
IMP_RES_TAC EQ_IMP_THM      
IMP_RES_TAC AND_INTRO_THM                             
PAT_X_ASSUM ``!x'. A `` (ASSUME_TAC o (Q.SPECL [`BVar "Adv" (BType_Imm Bit64)`]))
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [translate_birvar_to_sapicvar_def]
                                     
rewrite_tac[symb_interpr_update_def]
ASM_SIMP_TAC (srw_ss()) [sapic_renaming_dom_def,symb_interpr_dom_def]            
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [sapic_renaming_update_def,symb_interpr_dom_def,sapic_renaming_dom_def,symb_interpr_update_def,env_of_tree_def,IMAGE_DEF,EXTENSION]
rw[UPDATE_def]
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [IMAGE_DEF,EXTENSION]

rw[]
eq_tac
rw[]


RES_TAC


metis_tac[]
DB.find "UPDATE_DEF"
             
Q.EXISTS_TAC `symbtree_to_sapic Tree'` >> Q.EXISTS_TAC `i'+1` >> Q.EXISTS_TAC `Re` >> Q.EXISTS_TAC `NRe` >>  Q.EXISTS_TAC `[]`>>
rw[sim_def]>>
metis_tac[symbtree_to_sapic_def]>>
IMP_RES_TAC env_of_val_thm >>
ASM_SIMP_TAC (srw_ss()) [EXTENSION] >>
Q.EXISTS_TAC `Re` >>
ASM_SIMP_TAC (srw_ss()) [] >>
>>          

val sim_def = Define`
                   ( sim Tr (Config (Ns,St,Pold,Sb,Al)) =
                     ((∃Pro. (BAG_IN Pro Pold) ∧ (Pro = (symbtree_to_sapic Tr))) ∧
                      (∃(Re: sapic_renaming_t). (sapic_renaming_dom Re = IMAGE translate_birvar_to_sapicvar (symb_interpr_dom (THE (env_of_tree Tr)))))
                      ))
`; 
        
val sim_def = Define`
                   ( sim Tr (Config (Ns,St,Pold,Sb,Al)) =
((Pold = {|(symbtree_to_sapic Tr)|}) ∧
(sapic_substitution_dom Sb = IMAGE translate_birvar_to_sapicvar (symb_interpr_dom (THE (env_of_tree Tr))))))
`;

val sim_def = Define`
(sim (SNode (e,i,H) st) (Config (Ns,St,Pold,Sb,Al)) =
 (∀Pro v. (BAG_IN Pro Pold) ∧
          (if (e = (Sync_Fr v))
           then
                (∃(NRe: sapic_name_renaming_t). (Pro = (applyName (position (symbtree_to_sapic (SNode ((Sync_Fr v),i,H) st)) i) NRe)))
           else
             (∃(Re: sapic_renaming_t). (Pro = (apply (position (symbtree_to_sapic (SNode (e,i,H) st)) i) Re)))
             ))) /\ 
(sim (SBranch (e,i,H) lst rst) (Config (Ns,St,Pold,Sb,Al)) =
(∀Pro v. (BAG_IN Pro Pold) ∧ (∃(Re: sapic_renaming_t).
                              (Pro = (apply (position (symbtree_to_sapic (SBranch (e,i,H) lst rst)) i) Re)) ∧ (e = (Branch v)))))  /\                         
(sim (SLeaf) (Config (Ns,St,Pold,Sb,Al)) = T )                              
 `;
 
val sim_def = Define`
(sim (SNode (e,i,H) st) (Config (Ns,St,Pold,Sb,Al)) =
(∀Pro v. (BAG_IN Pro Pold) ∧ (∃(Re: sapic_renaming_t) (NRe: sapic_name_renaming_t).
                              ((Pro = (apply (position (symbtree_to_sapic (SNode (e,i,H) st)) i) Re)) ∧ (e ≠ (Sync_Fr v))) ∨
                                                 ((e = (Sync_Fr v)) ∧ (Pro = (applyName (position (symbtree_to_sapic (SNode ((Sync_Fr v),i,H) st)) i) NRe)))))) /\
 (sim (SBranch (e,i,H) lst rst) (Config (Ns,St,Pold,Sb,Al)) =
(∀Pro v. (BAG_IN Pro Pold) ∧ (∃(Re: sapic_renaming_t).
                              (Pro = (apply (position (symbtree_to_sapic (SBranch (e,i,H) lst rst)) i) Re)) ∧ (e = (Branch v)))))  /\                         
(sim (SLeaf) (Config (Ns,St,Pold,Sb,Al)) = T )                              
 `;
 
val sim_def = Define`
                    sim Tr (Config (Ns,St,Pold,Sb,Al)) =
((Pold = {|(symbtree_to_sapic Tr)|}) ∧
(∀eve env. (((THE (val_of_tree Tr)) = (eve,env)) ∧ ((val_of_tree Tr ≠ NONE))) ∧
(∀x. ((THE (sapic_substitution_get Sb (translate_birvar_to_sapicvar x))) =  translate_birexp_to_sapicterm (THE (symb_interpr_get env x))) ∧ ((symb_interpr_get env x) ≠ NONE) ∧ ((sapic_substitution_get Sb (translate_birvar_to_sapicvar x)) ≠ NONE)) ∧
(sapic_substitution_dom Sb = IMAGE translate_birvar_to_sapicvar (symb_interpr_dom env))
))
`;
                
val sim_def = Define`
                   ( sim Tr (Config (Ns,St,Pold,Sb,Al)) =
((Pold = {|(symbtree_to_sapic Tr)|}) ∧
(sapic_substitution_dom Sb = IMAGE translate_birvar_to_sapicvar (symb_interpr_dom (THE (env_of_tree Tr))))))
`;  

val sim_def = Define`
                    sim (eve,env) (Config (Ns,St,Pold,Sb,Al)) =
(
(∀T. ((THE (val_of_tree T)) = (eve,env)) ∧ (Pold = {|(symbtree_to_sapic T)|})) ∧
(∀x. (THE (sapic_substitution_get Sb (translate_birvar_to_sapicvar x))) =  translate_birexp_to_sapicterm (THE (symb_env_get env x))) ∧
(sapic_substitution_dom Sb = IMAGE translate_birvar_to_sapicvar (symb_env_dom env))
)
`;                             
val symbtree_to_sapic_def = Define `
    symbtree_to_sapic holtree  =
case holtree of
SLeaf => ProcessNull
| SBranch (a,b) lstr rstr  => ProcessComb (Cond (translate_birexp_to_sapicterm b)) (symbtree_to_sapic lstr) (symbtree_to_sapic rstr)
| SNode ((BVar name type),b) str  =>  (
if ((IS_SUFFIX name "assert_true_cnd") /\ (IS_SUFFIX name "assert_false_cnd") /\ (IS_SUFFIX name "cjmp_false_cnd")) then (symbtree_to_sapic str)
else (ProcessComb  (Let (TVar (translate_birvar_to_sapicvar (BVar name type))) (translate_birexp_to_sapicterm b)) (symbtree_to_sapic str) (ProcessNull)) 
)
                                      `;

val sim_def = Define`
                    sim snod conf =
((THE (sapic_substitution_get (get_substitution_conf conf) (translate_birvar_to_sapicvar (FST snod)))) = (translate_birexp_to_sapicterm (SND snod)))
`;

val _ = new_constant("trans", ``:(bir_var_t -> bir_exp_t option) -> (Var_t -> SapicTerm_t option)``);   
                      
val tree_node_to_process_thm = store_thm(
  "tree_node_to_process",
        ``∀(Tree: bir_exp_t stree) (var: bir_exp_t) (valu: bir_exp_t). ((var,valu) ∈ (STATES Tree)) ⇒ (∃(C:sapic_configuration_t). THE (sapic_substitution_get (get_substitution_conf C) (THE ( var_of_term (translate_birexp_to_sapicterm var)))) = (translate_birexp_to_sapicterm valu))``,
                           rpt strip_tac >>
                           Q.EXISTS_TAC `Config (Ns,St,Pold,(Substitution Sb),Al)`>>
                       rewrite_tac[sapic_substitution_get_def,get_substitution_conf_def] >>
                       Cases_on `var` >>
                       rewrite_tac[translate_birexp_to_sapicterm_def]

                        
  );


val tree_node_to_process_thm = store_thm(
  "tree_node_to_process",
        ``∀(Tree: (bir_var_t,bir_exp_t) stree) (var: bir_var_t) (valu: bir_exp_t). ((var,valu) ∈ (STATES Tree)) ⇒ (∃(C:sapic_configuration_t). THE (sapic_substitution_get (get_substitution_conf C) (translate_birvar_to_sapicvar var)) = (translate_birexp_to_sapicterm valu))``,
        rpt strip_tac >>
                           Q.EXISTS_TAC `Config (Ns,St,Pold,(Substitution Sb),Al)`>>
                       rewrite_tac[sapic_substitution_get_def,get_substitution_conf_def] >>
                       Cases_on `var` >>
                           
   rewrite_tac[translate_birvar_to_sapicvar_def]                     
  );
    
  translate_birexp_to_sapicterm x

translate_birexp_to_sapicterm (BExp_Const (Imm64 64w)) = Con (Name PubName "64")

 

val tree_node_to_process_thm = store_thm(
  "tree_node_to_process",
        ``∀(Tree: (bir_var_t,bir_exp_t) stree) (snod: (bir_var_t # bir_exp_t)) (snod': (bir_var_t # bir_exp_t)) (C:sapic_configuration_t).
        ((connected Tree snod snod') ∧ (sim snod C))
        ⇒ (∃(C':sapic_configuration_t). sim snod' C')``,
        gen_tac >>
        Cases_on `Tree`
rewrite_tac[connected_def]
rewrite_tac[connected_def]
reverse (Cases_on `s`)
rewrite_tac[val_of_tree_def]
        
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
rewrite_tac[sim_def]
gen_tac

     (Cases_on `C`)
       Cases_on `p''`
       Cases_on `r`
       Cases_on `r'`
       rewrite_tac[get_substitution_conf_def]
       Cases_on `q'''`
       rewrite_tac[sapic_substitution_get_def]
       strip_tac
                           Q.EXISTS_TAC `Config (Ns,St,Pold,(Substitution f),Al)`>>
                       rewrite_tac[sapic_substitution_get_def,get_substitution_conf_def] >>
                       Cases_on `var` >>
                           
   asm_rewrite_tac[translate_birvar_to_sapicvar_def]                     
  );
       DB.find "THE NONE"

val tree_node_to_process_thm = store_thm(
  "tree_node_to_process",
        ``∀Tree Tree' Ns St Pold Sb Al.
        (((single_step_execute_symbolic_tree Tree) = Tree' ) ∧ (sim Tree (Config (Ns,St,Pold,Sb,Al))))
        ⇒ (∃Ns' St' Pold' Sb' Al' Ev. (sim Tree' (Config (Ns',St',Pold',Sb',Al'))) ∧ (sapic_transition (Config (Ns,St,Pold,Sb,Al)) Ev (Config (Ns',St',Pold',Sb',Al'))))``,
       rewrite_tac[sim_def]>>
gen_tac >>
     reverse(Cases_on `Tree`)>- (
(Cases_on `p`) >>
(Cases_on `r`) >>
reverse (Cases_on `q`) >| [
(rewrite_tac[single_step_execute_symbolic_tree_def,symbtree_to_sapic_def,val_of_tree_def,THE_DEF] >>
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []>>
rewrite_tac[symbtree_to_sapic_def,val_of_tree_def,THE_DEF]>>
rw[] >>
Q.EXISTS_TAC `Ns` >> Q.EXISTS_TAC `St` >> Q.EXISTS_TAC `Sb` >>  Q.EXISTS_TAC `Al` >> Q.EXISTS_TAC `[]` >>
rw[sapic_transition_def])
]


         );
        
val tree_node_to_process_thm = store_thm(
  "tree_node_to_process",
        ``∀Tree Tree' Ns St Pold Sb Al.
        (((single_step_execute_symbolic_tree Tree) = Tree' ) ∧ (sim Tree (Config (Ns,St,Pold,Sb,Al))))
        ⇒ (∃Ns' St' Pold' Sb' Al' Ev. (sim Tree' (Config (Ns',St',Pold',Sb',Al'))))``,
rewrite_tac[sim_def]>>
gen_tac >>
     reverse(Cases_on `Tree`)>- (
(Cases_on `p`) >>
(Cases_on `r`) >>
reverse (Cases_on `q`) >|
[rewrite_tac[single_step_execute_symbolic_tree_def,symbtree_to_sapic_def,val_of_tree_def,THE_DEF] >>
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []>>
rewrite_tac[symbtree_to_sapic_def,val_of_tree_def,THE_DEF]>>
rw[] >>
Q.EXISTS_TAC `Sb` >>  
rw[]]
 >>
(Cases_on `p`) >>
(Cases_on `r`) >>
reverse (Cases_on `q`) >-(
rewrite_tac[single_step_execute_symbolic_tree_def,symbtree_to_sapic_def,val_of_tree_def,THE_DEF] >>
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []>>
rewrite_tac[symbtree_to_sapic_def,val_of_tree_def,THE_DEF]>>
rpt strip_tac>>
(Cases_on `Sb`) >>
(Cases_on `b`) >>          
Q.EXISTS_TAC `Substitution (((translate_birvar_to_sapicvar (BVar "crypto" (BType_Imm Bit64))) =+ SOME (TVar (translate_birvar_to_sapicvar (BVar s b')))) f')` >>
rewrite_tac[symb_interpr_dom_def,sapic_substitution_get_def,sapic_substitution_dom_def,symb_interpr_get_def,translate_birvar_to_sapicvar_def]
rpt strip_tac >>
rewrite_tac[symb_interpr_dom_def,sapic_substitution_get_def,sapic_substitution_dom_def,symb_interpr_get_def,translate_birvar_to_sapicvar_def] >>
metis_tac[symb_interpr_dom_def,sapic_substitution_get_def,sapic_substitution_dom_def,symb_interpr_get_def,translate_birvar_to_sapicvar_def] >>
IMP_RES_TAC NOT_SOME_NONE >>

PAT_X_ASSUM ``! eve env. A `` (ASSUME_TAC o (Q.SPECL [`Crypto (BVar s b')`,`symb_interpr_update H (x,SOME (BExp_Den (BVar s b')))`]))>>  
PAT_X_ASSUM ``! eve env. A `` (ASSUME_TAC o (Q.SPECL [`Crypto (BVar s b')`,`SEnv f⦇BVar "crypto" (BType_Imm Bit64) ↦ SOME (BExp_Den (BVar s b'))⦈`]))>>                                                                            rewrite_tac [APPLY_UPDATE_THM]
metis_tac[]
IMP_RES_TAC symb_interpr_get_update_id_thm
RES_TAC
                                                                   
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [] >>
rw[] >>
metis_tac[symb_env_dom_def,sapic_substitution_get_def,sapic_substitution_dom_def,symb_env_get_def,translate_birvar_to_sapicvar_def]
(Cases_on `x`)
(Cases_on `env`)
rewrite_tac[symb_env_dom_def,sapic_substitution_get_def,sapic_substitution_dom_def,symb_env_get_def,translate_birvar_to_sapicvar_def]        


PAT_X_ASSUM ``! eve env. A `` (ASSUME_TAC o (Q.SPECL [`Crypto (BVar s b')`,`SEnv f⦇BVar "crypto" (BType_Imm Bit64) ↦ SOME (BExp_Den (BVar s b'))⦈`]))>>
            
 rewrite_tac[symb_env_dom_def,sapic_substitution_get_def,sapic_substitution_dom_def,symb_env_get_def]            
rewrite_tac[translate_birvar_to_sapicvar_def]
metis_tac[symb_env_dom_def,sapic_substitution_get_def,sapic_substitution_dom_def,symb_env_get_def,translate_birvar_to_sapicvar_def,translate_birexp_to_sapicterm_def]
Q.EXISTS_TAC `Al` >> Q.EXISTS_TAC `[]` >>
rw[sapic_transition_def]
rw[translate_birvar_to_sapicvar_def]
rw[translate_birexp_to_sapicterm_def]

IMP_RES_TAC symb_env_get_def
IMP_RES_TAC sapic_substitution_get_def 
reverse(rw[])  
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [IMAGE_DEF,IN_DEF]
)

      APPLY_UPDATE_THM
PAT_X_ASSUM ``!x. A `` (ASSUME_TAC o (Q.SPECL [`x`]))>>

PAT_X_ASSUM ``! eve env. A `` (ASSUME_TAC o (Q.SPECL [`Crypto (BVar s b')`,`SEnv f''`]))>>
asm_rewrite_tac[]

ASM_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [symb_env_dom_def,sapic_substitution_get_def,sapic_substitution_dom_def,symb_env_get_def,translate_birvar_to_sapicvar_def,translate_birexp_to_sapicterm_def,IMAGE_DEF,IN_DEF]
IMP_RES_TAC AND1_THM
RES_TAC

  ASM_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [symb_interpr_get_update_id_thm]     
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [single_step_execute_symbolic_tree_def,val_of_tree_def] >>
 (Cases_on `p`) >>
rw[] >>
Q.EXISTS_TAC `Ns'` >> Q.EXISTS_TAC `St'` >> Q.EXISTS_TAC `Sb` >>  Q.EXISTS_TAC `Al'` >> Q.EXISTS_TAC `Ev`
rw[] >- (
reverse (Cases_on `q`)
(Cases_on `r`)
rewrite_tac[single_step_execute_symbolic_tree_def]
rewrite_tac[symbtree_to_sapic_def]
rewrite_tac[val_of_tree_def,THE_DEF]
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
rw[]
rw[sapic_transition_def]
rpt strip_tac
rewrite_tac[sapic_transition_def,sapic_null_transition_def]


        Q.EXISTS_TAC `Ns` >> Q.EXISTS_TAC `St` >> Q.EXISTS_TAC `Sb` >>  Q.EXISTS_TAC `Al` >> Q.EXISTS_TAC `[]`

   reverse     (rw[])
              
PAT_X_ASSUM ``! eve env. A `` (ASSUME_TAC o (Q.SPECL [`Crypto b`,`SEnv f`]))>>
RES_TAC

          
metis_tac[]
rewrite_tac[sim_def]
gen_tac

     (Cases_on `C`)
       Cases_on `p''`
       Cases_on `r`
       Cases_on `r'`
       rewrite_tac[get_substitution_conf_def]
       Cases_on `q'''`
       rewrite_tac[sapic_substitution_get_def]
       strip_tac
                           Q.EXISTS_TAC `Config (Ns,St,Pold,(Substitution f),Al)`>>
                       rewrite_tac[sapic_substitution_get_def,get_substitution_conf_def] >>
                       Cases_on `var` >>
                           
   asm_rewrite_tac[translate_birvar_to_sapicvar_def]                     
  );          






∀E Tree Tree' Ns St Pold Sb Al.
        (((single_step_execute_symbolic_tree Tree E Tree' ) ∧ (sim Tree (Config (Ns,St,Pold,Sb,Al))))
        ⇒ (∃Ns' St' Pold' Sb' Al' Ev. (sim Tree' (Config (Ns',St',Pold',Sb',Al'))) ∧ (sapic_position_transition (symbtree_to_sapic Tree) (Config (Ns,St,Pold,Sb,Al)) Ev (Config (Ns',St',Pold',Sb',Al')))))

gen_tac >>
reverse(Cases_on ‘E’)
rw[single_step_execute_symbolic_tree_def]>>
IMP_RES_TAC sim_def>>
Q.EXISTS_TAC `Ns` >> Q.EXISTS_TAC `St` >> Q.EXISTS_TAC `Pold` >> Q.EXISTS_TAC `Sb` >>  Q.EXISTS_TAC `Al` >> Q.EXISTS_TAC `[]`>>
rw[sim_def]>>
metis_tac[symbtree_to_sapic_def]>>
IMP_RES_TAC env_of_val_thm >>
ASM_SIMP_TAC (srw_ss()) [] >>
Q.EXISTS_TAC `Re` >>
ASM_SIMP_TAC (srw_ss()) [] >>
rewrite_tac[env_of_tree_def]>>
ASM_SIMP_TAC (srw_ss()) []>>
rw[sapic_position_transition_def]


rw[single_step_execute_symbolic_tree_def]>>
IMP_RES_TAC sim_def>>
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [symbtree_to_sapic_def]
rw[sapic_position_transition_def]
rw[sapic_position_conditional_true_transition_def,sapic_position_conditional_false_transition_def]                    
Q.EXISTS_TAC `Ns` >> Q.EXISTS_TAC `St` >> Q.EXISTS_TAC `Ps ⊎ {|symbtree_to_sapic Tree'|}` >> Q.EXISTS_TAC `Sb` >>  Q.EXISTS_TAC `Al` >> Q.EXISTS_TAC `[]`>>
rw[sim_def]>>
IMP_RES_TAC env_of_val_thm >>
ASM_SIMP_TAC (srw_ss()) [] >>
Q.EXISTS_TAC `Re` >>
ASM_SIMP_TAC (srw_ss()) [] >>
rewrite_tac[env_of_tree_def]>>
ASM_SIMP_TAC (srw_ss()) []>>
metis_tac[]
DB.find "BAG_INN"

              
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [symbtree_to_sapic_def]
ASM_SIMP_TAC (list_ss++bagSimps.BAG_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
open bagSimps;

              
gen_tac >>
Cases_on ‘E’
rw[single_step_execute_symbolic_tree_def]
IMP_RES_TAC sim_def
rewrite_tac[symbtree_to_sapic_def]
rw[sapic_position_transition_def]
rw[sapic_position_out_transition_def]

Q.EXISTS_TAC `Ns` >> Q.EXISTS_TAC `St` >> Q.EXISTS_TAC `Pold` >> Q.EXISTS_TAC `Sb` >>  Q.EXISTS_TAC `Al` >> Q.EXISTS_TAC `[]`
rw[sim_def]
metis_tac[symbtree_to_sapic_def]
IMP_RES_TAC env_of_val_thm >>
ASM_SIMP_TAC (srw_ss()) [] >>
Q.EXISTS_TAC `Re` >>
ASM_SIMP_TAC (srw_ss()) [] >>
rewrite_tac[env_of_tree_def]>>
ASM_SIMP_TAC (srw_ss()) []
rw[sapic_position_transition_def]


IMP_RES_TAC symbtree_to_sapic_def
                             
Cases_on ‘Tree'’
rewrite_tac[sapic_position_transition_def]
rw[]
RES_TAC
IMP_RES_TAC symbtree_to_sapic_def

IMP_RES_TAC sbir_event_distinct
                     
rewrite_tac[single_step_execute_symbolic_tree_def]
ASM_SIMP_TAC (srw_ss()) []
rpt gen_tac
rpt strip_tac
RES_TAC
rw[single_step_execute_symbolic_tree_def,sim_def]
rewrite_tac[sim_def]
        
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [symbtree_to_sapic_def]
rw[]
case_def
TypeBasePure.case_def_of
optionTheory.option_CLAUSES
pair_CASE_def
DB.find "CASE_DEF"


              
∀E Tree Tree' Ns St Pold Sb Al.
        (((single_step_execute_symbolic_tree Tree E Tree' ) ∧ (sim Tree (Config (Ns,St,Pold,Sb,Al))))
        ⇒ (∃Ns' St' Pold' Sb' Al' Ev. (sim Tree' (Config (Ns',St',Pold',Sb',Al'))) ∧ (sapic_transition (Config (Ns,St,Pold,Sb,Al)) Ev (Config (Ns',St',Pold',Sb',Al')))))                    

gen_tac >>
reverse(Cases_on ‘E’) >>
rw[single_step_execute_symbolic_tree_def]>>
IMP_RES_TAC sim_def >>
ASM_SIMP_TAC (srw_ss()) []>>
rewrite_tac[symbtree_to_sapic_def]>>
Q.EXISTS_TAC `Ns` >> Q.EXISTS_TAC `St` >> Q.EXISTS_TAC `{|symbtree_to_sapic Tree'|}` >> Q.EXISTS_TAC `Sb` >>  Q.EXISTS_TAC `Al` >> Q.EXISTS_TAC `[]`>>            
rw[sim_def]>>
IMP_RES_TAC env_of_val >>
rewrite_tac[env_of_tree_def] >>
ASM_SIMP_TAC (srw_ss()) [] >>
rewrite_tac[sapic_transition_def]


rw[single_step_execute_symbolic_tree_def]>>
IMP_RES_TAC sim_def >>
ASM_SIMP_TAC (srw_ss()) []>>
rewrite_tac[symbtree_to_sapic_def]>>
Q.EXISTS_TAC `Ns` >> Q.EXISTS_TAC `St` >> Q.EXISTS_TAC `{|symbtree_to_sapic Tree'|}` >> Q.EXISTS_TAC `sapic_substitution_update Sb (Var "att" n, SOME (translate_birexp_to_sapicterm (BExp_Den b)))` >>  Q.EXISTS_TAC `Al` >> Q.EXISTS_TAC `Ev`>>            
rw[sim_def]>>
IMP_RES_TAC env_of_val >>
Cases_on ‘Sb’
rewrite_tac[sapic_substitution_update_def]
IMP_RES_TAC env_of_tree_def >>
ASM_SIMP_TAC (srw_ss()) [] >>
rewrite_tac[sapic_transition_def]
reverse(rw[])
        
Q.EXISTS_TAC ‘{||}’ >> Q.EXISTS_TAC ‘ProcessComb (Cond (translate_birexp_to_sapicterm (BExp_Den b)))
              (symbtree_to_sapic Tree') (symbtree_to_sapic rst)’ >>
ASM_SIMP_TAC (srw_ss()) [] >>
rewrite_tac[sapic_out_transition_def]
ASM_SIMP_TAC (srw_ss()) []

rw[OR_INTRO_THM1]
        

IMP_RES_TAC val_of_tree_def

ASM_SIMP_TAC (srw_ss()) [OR_INTRO_THM1]

Q.EXISTS_TAC `Ns` >> Q.EXISTS_TAC `St` >> Q.EXISTS_TAC `{|symbtree_to_sapic Tree'|}` >> Q.EXISTS_TAC `Sb` >>  Q.EXISTS_TAC `Al` >> Q.EXISTS_TAC `[]`

PAT_X_ASSUM ``!ev i' env. A `` (ASSUME_TAC o (Q.SPECL [`Silent`,`i+1`,‘H’]))>>
rewrite_tac[sapic_transition_def]
rw[]
rw[sim_def]
ASM_SIMP_TAC (srw_ss()) [env_of_tree_def]
rewrite_tac[env_of_tree_def]
ASM_SIMP_TAC (srw_ss()) []

IMP_RES_TAC env_of_val 
Cases_on ‘Tree'’

         DB.find "OR_REFL"


∀E Tree Tree' Ns St Pold Sb Al.
        (((single_step_execute_symbolic_tree Tree E Tree' ) ∧ (sim Tree (Config (Ns,St,Pold,Sb,Al))))
        ⇒ (∃Ns' St' Pold' Sb' Al' Ev. (sim Tree' (Config (Ns',St',Pold',Sb',Al')))))  

gen_tac >>
reverse(Cases_on ‘E’) >>
rw[single_step_execute_symbolic_tree_def]>>
IMP_RES_TAC sim_def >>
ASM_SIMP_TAC (srw_ss()) []>>
IMP_RES_TAC symbtree_to_sapic_def>>
Q.EXISTS_TAC `Ns` >> Q.EXISTS_TAC `St` >> Q.EXISTS_TAC `{|symbtree_to_sapic Tree'|}` >> Q.EXISTS_TAC `Sb` >>  Q.EXISTS_TAC `Al` >>       
rw[sim_def]>>
IMP_RES_TAC env_of_val >>
rewrite_tac[env_of_tree_def] >>
ASM_SIMP_TAC (srw_ss()) [] >>



*)

(*


DISCH_TAC        
metis_tac[sapic_position_multi_transitions_ind,sapic_position_multi_transitions_def]
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [sapic_position_multi_transitions_def]

        
val symbtree_to_sapic_single_step_simulation_thm = store_thm(
  "symbtree_to_sapic_single_step_simulation_thm",
  ``
∀Tev Pev T0 Tree H0 Re0 NRe0 Pro i Re NRe.
  ((val_of_tree T0 = SOME (Silent,0,H0))∧
  (symb_interpr_dom H0 = ∅) ∧
  (sapic_renaming_dom Re0 = ∅) ∧
  (execute_symbolic_tree T0 Tev Tree) ∧ (sapic_position_multi_transitions (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)) (MAP sbirEvent_to_sapicFact Tev) (Pconfig (Pro,i,Re,NRe))))
  ⇒ (sim Tree (Pconfig (Pro,i,Re,NRe)))``,
gen_tac>>
  Cases_on ‘Tev’ >-(
    rw[execute_symbolic_tree_def]>>
    IMP_RES_TAC sapic_position_multi_transitions_def>>
    FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [sapic_position_multi_transitions_def]>>
                  metis_tac[symbtree_to_sapic_initial_state_simulation_thm]
)
>-(
rpt strip_tac
IMP_RES_TAC execute_symbolic_tree_def
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
IMP_RES_TAC sapic_position_multi_transitions_def
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
IMP_RES_TAC symbtree_to_sapic_single_step_simulation_thm

         

val symbtree_to_sapic_single_step_simulation_thm = store_thm(
  "symbtree_to_sapic_single_step_simulation_thm",
  ``
∀Tev Pev T0 Tree H0 Re0 NRe0 Pro i Re NRe.
  ((sim T0 (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)))∧
  (execute_symbolic_tree T0 Tev Tree) ∧
  (sapic_position_multi_transitions (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)) (MAP sbirEvent_to_sapicFact Tev) (Pconfig (Pro,i,Re,NRe))))
  ⇒ (sim Tree (Pconfig (Pro,i,Re,NRe)))``,
gen_tac>>
  Cases_on ‘Tev’ >-(
    rw[execute_symbolic_tree_def]>>
    IMP_RES_TAC sapic_position_multi_transitions_def>>
    FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [sapic_position_multi_transitions_def]>>
                  metis_tac[symbtree_to_sapic_initial_state_simulation_thm]
)
>-(
rpt strip_tac
IMP_RES_TAC execute_symbolic_tree_def
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
IMP_RES_TAC sapic_position_multi_transitions_def
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
IMP_RES_TAC symbtree_to_sapic_single_step_simulation_thm

            metis_tac[symbtree_to_sapic_single_step_simulation_thm]

)        
)










        
val symbtree_to_sapic_single_step_simulation_thm = store_thm(
  "symbtree_to_sapic_single_step_simulation_thm",
  ``
∀Tev Pev T0 Tree H0 Re0 NRe0 Pro i Re NRe.
  ((val_of_tree T0 = SOME (Silent,0,H0))∧
  (symb_interpr_dom H0 = ∅) ∧
  (sapic_renaming_dom Re0 = ∅) ∧
  (execute_symbolic_tree T0 Tev Tree) ∧ (sapic_position_multi_transitions (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)) (MAP sbirEvent_to_sapicFact Tev) (Pconfig (Pro,i,Re,NRe))))
  ⇒ (sim Tree (Pconfig (Pro,i,Re,NRe)))``,
gen_tac>>
  Cases_on ‘Tev’ >-(
    rw[execute_symbolic_tree_def]>>
    IMP_RES_TAC sapic_position_multi_transitions_def>>
    FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [sapic_position_multi_transitions_def]>>
                  metis_tac[symbtree_to_sapic_initial_state_simulation_thm]
)
>-(
rpt strip_tac
IMP_RES_TAC execute_symbolic_tree_def
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
IMP_RES_TAC sapic_position_multi_transitions_def
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
IMP_RES_TAC symbtree_to_sapic_single_step_simulation_thm
PAT_X_ASSUM ``!i Re Pro NRe. A`` (ASSUME_TAC o (Q.SPECL [`i'`,`Re'`,`Pro'`,`NRe'`])) >>
        RES_TAC
)        
)



val symbtree_to_sapic_single_step_simulation_thm = store_thm(
  "symbtree_to_sapic_single_step_simulation_thm",
  ``
∀Tev T0 Tree H0 Re0 NRe0.
  ((execute_symbolic_tree T0 Tev Tree) ∧
  (sim T0 (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0))))
  ⇒
  (∃Pro i Re NRe Pev. (sapic_position_multi_transitions (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)) Pev (Pconfig (Pro,i,Re,NRe))) ∧
  (sim Tree (Pconfig (Pro,i,Re,NRe))))``,
gen_tac>>
  Cases_on ‘Tev’ >-(
    rw[execute_symbolic_tree_def]>>
    Q.EXISTS_TAC `symbtree_to_sapic T0` >>
    Q.EXISTS_TAC `0` >>
    Q.EXISTS_TAC `Re0` >>
    Q.EXISTS_TAC `NRe0` >>
    Q.EXISTS_TAC `[]` >>
    rw[sapic_position_multi_transitions_def]    
)
>-(
rpt strip_tac
IMP_RES_TAC execute_symbolic_tree_def
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
IMP_RES_TAC symbtree_to_sapic_single_step_simulation_thm
rewrite_tac[sapic_position_multi_transitions_def]
    Q.EXISTS_TAC `Pro'` >>
    Q.EXISTS_TAC `i'` >>
    Q.EXISTS_TAC `Re'` >>
    Q.EXISTS_TAC `NRe'` >>
    Q.EXISTS_TAC `e::ev` >>
    ASM_SIMP_TAC (srw_ss()) []
)        
)







rpt strip_tac
IMP_RES_TAC execute_symbolic_tree_def
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
IMP_RES_TAC sapic_position_multi_transitions_def
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
IMP_RES_TAC symbtree_to_sapic_single_step_simulation_thm
metis_tac[symbtree_to_sapic_single_step_simulation_thm]
PAT_X_ASSUM ``!i Re Pro NRe. A`` (ASSUME_TAC o (Q.SPECL [`i'`,`Re'`,`Pro'`,`NRe'`])) >>
        RES_TAC
        
val TreeTransNil = new_axiom ("TreeTransNil",
                            ``∀T e. (execute_symbolic_tree T e T) ⇒
                            (e = [])``);        
val PTransEq = new_axiom ("PTransEq",
                            ``∀C C' e e'. (sapic_position_multi_transitions C e C') ∧ (sapic_position_multi_transitions C e' C') ⇒ (e = e')``);

val TreeTransEq = new_axiom ("TreeTransEq",
                            ``∀e e' T T'. (execute_symbolic_tree T e T') ∧ (execute_symbolic_tree T e' T') ⇒ (e = e')``
                           gen_tac
                           gen_tac
Cases_on  ‘e = e'’                           
metis_tac[]

       Cases_on ‘e’
       rpt strip_tac
       IMP_RES_TAC execute_symbolic_tree_def
       FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
       metis_tac[TreeTransNil]

       
       
);
                                                        
val symbtree_to_sapic_single_step_simulation_thm = store_thm(
  "symbtree_to_sapic_single_step_simulation_thm",
  ``
∀Tev Pev T0 Tree H0 Re0 NRe0 Pro i Re NRe.
  ((execute_symbolic_tree T0 Tev Tree) ∧
  (sapic_position_multi_transitions (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)) (MAP sbirEvent_to_sapicFact Tev) (Pconfig (Pro,i,Re,NRe)))∧
  (sim T0 (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0))))
  ⇒ (traces_of_sapic (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)) (Pconfig (Pro,i,Re,NRe))) = ((IMAGE (MAP sbirEvent_to_sapicFact) (traces_of_tree T0 Tree)))``,


∀Tev Pev T0 Tree H0 Re0 NRe0 Pro i Re NRe.
  (sim T0 (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)))
  ⇒ ((IMAGE (MAP sbirEvent_to_sapicFact) (traces_of_tree T0 Tree)) = (traces_of_sapic (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)) (Pconfig (Pro,i,Re,NRe))))






            
FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) [MAP]
    
    IMP_RES_TAC MAP
    IMP_RES_TAC sbirEvent_to_sapicFact_def
Cases_on ‘x'’
rw[execute_symbolic_tree_def]
metis_tac[sapic_position_multi_transitions_nilmove]

    
    IMP_RES_TAC symbtree_to_sapic_trace_simulation_thm
    
metis_tac[symbtree_to_sapic_trace_simulation_thm]  
    
    Cases_on ‘x = (MAP sbirEvent_to_sapicFact Tev)’
    IMP_RES_TAC symbtree_to_sapic_trace_simulation_thm
    Q.EXISTS_TAC `Tev`
    ASM_SIMP_TAC (srw_ss()) []
    metis_tac[PTransEq]
    )
   rpt strip_tac
   ASM_SIMP_TAC (srw_ss()) []
    metis_tac[TreeTransEq]


 metis_tac[symbtree_to_sapic_trace_simulation_thm,symbtree_to_sapic_initial_state_simulation_thm,symbtree_to_sapic_single_step_simulation_thm,sbirEvent_to_sapicFact_def]  

 


∀Tev Tree Tree. Tev ∈ (traces_of_tree Tree Tree') ⇒
(∃Pev Pro i Re NRe Pro' i' Re' NRe'. (Pev ∈ (traces_of_sapic (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)) (Pconfig (Pro,i,Re,NRe)))))
)

∀Tev T0 Tree Re0 NRe0. (Tev ∈ (traces_of_tree T0 Tree)) ∧ (sim T0 (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0))) ⇒
(∃Pev Pro i Re NRe. (Pev ∈ (traces_of_sapic (Pconfig ((symbtree_to_sapic T0),0,Re0,NRe0)) (Pconfig (Pro,i,Re,NRe)))) ∧ (trace_sim Tev Pev)
)
        

rewrite_tac[trace_sim_def]>>
rewrite_tac[traces_of_sapic_def]>>
rewrite_tac[traces_of_tree_def]>>
 FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []>>
rw[]>>
Induct_on ‘Tev’>-(
rw[ execute_symbolic_tree_def]>>
    Q.EXISTS_TAC `[]` >>
    Q.EXISTS_TAC `symbtree_to_sapic T0` >>
    Q.EXISTS_TAC `0` >>            
    Q.EXISTS_TAC `Re0` >>
    Q.EXISTS_TAC `NRe0` >>
rw[sapic_position_multi_transitions_nil]   >>
    Q.EXISTS_TAC `Pro` >>
    Q.EXISTS_TAC `i` >>            
    Q.EXISTS_TAC `Re` >>
    Q.EXISTS_TAC `NRe` >>
    ASM_SIMP_TAC (srw_ss()) [sapic_position_multi_transitions_nil]
    )
 rpt strip_tac>>
 IMP_RES_TAC symbtree_to_sapic_trace_simulation_thm>>
 Q.EXISTS_TAC `Ev` >>
    Q.EXISTS_TAC `Pro'` >>
    Q.EXISTS_TAC `i'` >>
    Q.EXISTS_TAC `Re'` >>
    Q.EXISTS_TAC `NRe'` >>
ASM_SIMP_TAC (srw_ss()) []
rw[]
IMP_RES_TAC execute_symbolic_tree_def>>
    FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []>>
IMP_RES_TAC symbtree_to_sapic_trace_simulation_thm

 Q.EXISTS_TAC `Pro'''''` >>
    Q.EXISTS_TAC `i'''''` >>
    Q.EXISTS_TAC `Re'''''` >>
    Q.EXISTS_TAC `NRe'''''` >>
    ASM_SIMP_TAC (srw_ss()) []           
 metis_tac[symbtree_to_sapic_trace_simulation_thm,symbtree_to_sapic_initial_state_simulation_thm,symbtree_to_sapic_single_step_simulation_thm]     
    
 FULL_SIMP_TAC (list_ss++pred_setSimps.PRED_SET_ss++boolSimps.LIFT_COND_ss++boolSimps.EQUIV_EXTRACT_ss) []
 Q.EXISTS_TAC `(pe::pev)` >>
    Q.EXISTS_TAC `Re0` >>
    Q.EXISTS_TAC `NRe0` >>
    Q.EXISTS_TAC `Pro` >>
    Q.EXISTS_TAC `i` >>
    Q.EXISTS_TAC `Re` >>
    Q.EXISTS_TAC `NRe` >>
    rw[sapic_position_multi_transitions_def]



val trace_sim_def = Define`
                   ( trace_sim Tev Pev =
                   (∃tre tre' Pro i Re NRe Pro' i' Re' NRe'.
                   (execute_symbolic_tree tre Tev tre')∧
                   (sapic_position_multi_transitions (Pconfig (Pro,i,Re,NRe)) Pev (Pconfig (Pro',i',Re',NRe'))) ∧
                     ((sim tre (Pconfig (Pro,i,Re,NRe))) ∧
                       (sim tre' (Pconfig (Pro',i',Re',NRe'))) 

                                       )))
`; 

rewrite_tac[sbirEvent_to_sapicFact_def]
∀E Tree Tree' Pro i Re NRe.
        (((single_step_execute_symbolic_tree Tree E Tree' ) ∧ (sim Tree (Pconfig (Pro,i,Re,NRe))))
         ⇒ (∃Pro' i' Re' NRe' Ev. (sim Tree' (Pconfig (Pro',i',Re',NRe'))) ∧ (sapic_position_transition (Pconfig (Pro,i,Re,NRe)) Ev (Pconfig (Pro',i',Re',NRe'))) ∧ (Ev = sbirEvent_to_sapicFact E)))
gen_tac
reverse(Cases_on‘E’)
          *)   
